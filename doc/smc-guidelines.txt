本文档汇集了一些建议和最佳实践，供在开发新的 TON 区块链智能合约时参考。

1. 内部消息
~~~~~~~~~~~~

智能合约通过发送所谓的 *内部消息* 进行交互。当内部消息到达其预定的目的地时，会为目标账户创建一个普通的交易，并按该账户（智能合约）的代码和持久数据处理该内部消息。
特别地，处理交易可以创建一个或多个出站内部消息，其中一些可能会发回给处理中的内部消息的源地址。这可以用来创建简单的“客户端-服务器应用程序”，
当查询被封装在内部消息中并发送到另一个智能合约时，该智能合约处理查询并以内部消息形式返回响应。

这就需要区分内部消息是作为“查询”还是作为“响应”，或者不需要任何额外处理（例如“简单的资金转移”）。此外，当收到响应时，必须有方法来理解它对应于哪个查询。

为了实现这个目标，可以使用以下推荐的内部消息布局（注意，TON 区块链不对消息体施加任何限制，因此这些实际上只是建议）：

0) 消息体可以嵌入到消息本身中，或者存储在消息所引用的单独单元中，如 TL-B 方案片段所示：

  ```
  message$_ {X:Type} ... body:(Either X ^X) = Message X;
  ```

接收的智能合约应该至少接受嵌入消息体的内部消息（只要它们适合包含消息的单元）。如果它接受单独单元中的消息体（使用 `(Either X ^X)` 的 `right` 构造器），
则入站消息的处理不应依赖于为消息体选择的具体嵌入选项。另一方面，对于更简单的查询和响应，完全可以不支持单独单元中的消息体。

1) 消息体通常以以下字段开始：

* 一个 32 位（大端）无符号整数 *op*，用于识别要执行的“操作”或要调用的智能合约的“方法”。
* 一个 64 位（大端）无符号整数 *query_id*，在所有查询-响应内部消息中，用于指示响应与查询的关系（响应的 *query_id* 必须等于相应查询的 *query_id*）。
如果 *op* 不是查询-响应方法（例如，它调用的是不期望返回答案的方法），则可以省略 *query_id*。
* 消息体的其余部分对每个支持的 *op* 值都是特定的。

2) 如果 *op* 为零，则消息是“简单转账消息带注释”。注释包含在消息体的其余部分（没有 *query_id* 字段，即从第五个字节开始）。
如果它不以字节 0xff 开头，则注释是文本注释；它可以“原样”显示给钱包的最终用户（在过滤无效和控制字符后，并检查它是否是有效的 UTF-8 字符串）。
例如，用户可以在这个文本字段中指明从他们的钱包到另一个用户的钱包的简单转账的目的。
另一方面，如果注释以字节 0xff 开头，则其余部分是“二进制注释”，不应作为文本显示给最终用户（如有必要，仅作为十六进制转储显示）。
例如，“二进制注释”的预期用途是包含商店的购买标识符，由商店的软件自动生成和处理。

大多数智能合约不应执行复杂的操作或在收到“简单转账消息”时拒绝入站消息。这样，一旦 *op* 被发现为零，
处理入站内部消息的智能合约函数（通常称为 `recv_internal()`）应立即以零退出代码指示成功（例如，如果智能合约没有安装自定义异常处理程序，则抛出异常 0）。
这将导致接收账户被记入消息转账的值，而不会有任何进一步的效果。

3) “没有注释的简单转账消息”具有空消息体（甚至没有 *op* 字段）。上述考虑也适用于这样的消息。请注意，这些消息的消息体应嵌入在消息单元中。

4) 我们期望“查询”消息的 *op* 高位清零，即在 1 .. 2^31-1 范围内，而“响应”消息的 *op* 高位设定，即在 2^31 .. 2^32-1 范围内。
如果一个方法既不是查询也不是响应（因此相应的消息体不包含 *query_id* 字段），它应该使用“查询”范围 1 .. 2^31 - 1 内的 *op*。

5) 有一些“标准”响应消息，其 *op* 等于 0xffffffff 和 0xfffffffe。一般来说，*op* 从 0xfffffff0 到 0xffffffff 的值保留用于这些标准响应。

* *op* = 0xffffffff 表示“操作不支持”。它后跟从原始查询提取的 64 位 *query_id* 和原始查询的 32 位 *op*。
所有但最简单的智能合约在收到范围 1 .. 2^31-1 的未知 *op* 查询时应返回此错误。
* *op* = 0xfffffffe 表示“操作不允许”。它后跟原始查询的 64 位 *query_id*，然后是原始查询的 32 位 *op*。

注意，未知的“响应”（*op* 在 2^31 .. 2^32-1 范围内）应被忽略（特别是，不应对它们生成 *op* 等于 0xffffffff 的响应），就像意外的回弹消息（设置了“回弹”标志）一样。

2. 支付查询处理和发送响应的费用
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

一般而言，如果智能合约想要向另一个智能合约发送查询，它应支付发送内部消息到目标智能合约的费用（消息转发费用）、处理该消息的费用（气体费用）以及在需要时发送回响应的费用（消息转发费用）。

在大多数情况下，发送方会将少量的 Grams（例如，一 Gram）附加到内部消息上（足以支付此消息的处理费用），并设置其“回弹”标志（即，发送可回弹的内部消息）；
接收方将在答案中返回未使用的部分（从中扣除消息转发费用）。这通常通过调用 SENDRAWMSG 并设置 mode=64 来实现（参见 TON VM 文档的附录 A）。

如果接收方无法解析收到的消息并以非零退出代码终止（例如，因为未处理的单元反序列化异常），消息将自动“回弹”回到发送方，标志设置为“回弹”，标志清除。
“回弹”消息的主体将与原始消息相同；因此，在智能合约中解析 *op* 字段并处理相应查询之前，检查入站内部消息的“回弹”标志非常重要（否则可能会将回弹消息中的查询作为新的单独查询由原始发送方处理）。
如果设置了“回弹”标志，则特殊代码可以找出哪个查询失败（例如，通过从回弹消息中反序列化 *op* 和 *query_id*）并采取适当的措施。更简单的智能合约可以简单地忽略所有回弹消息（如果“回弹”标志设置则以零退出代码终止）。

另一方面，接收方可能会成功解析入站查询并发现请求的方法 *op* 不受支持，或满足其他错误条件。
在这种情况下，应该发送一个 *op* 等于 0xffffffff 或其他适当值的响应，使用 SENDRAWMSG 并设置 mode=64，如前所述。

在某些情况下，发送方希望同时转移一些价值并收到确认或错误消息。例如，验证者选举智能合约接收一个选举参与请求以及作为附加值的质押。
在这种情况下，将额外的一个 Gram 附加到预期的价值是有意义的。
如果出现错误（例如，质押由于任何原因无法接受），应将收到的全部金额（减去处理费用）连同错误消息一起退还给发送方（例如，通过使用 SENDRAWMSG 并设置 mode=64）。
如果成功，则会创建确认消息并返回准确的一 Gram（从该金额中扣除消息转移费用；这是 SENDRAWMSG 的 mode=1）。

3. 使用不可回弹的消息
~~~~~~~~~~~~~~~~~~~~~~~~

几乎所有在智能合约之间发送的内部消息都应该是可回弹的，即应该设置“回弹”位。
这样，如果目标智能合约不存在，或者在处理消息时抛出未处理的异常，消息将被“回弹”回，携带原始值的剩余部分（减去所有消息转移和气体费用）。
回弹消息将具有相同的主体，但“回弹”标志设置，且“回弹”标志清除。
因此，所有智能合约都应该检查所有入站消息的“回弹”标志，或静默接受它们（通过立即以零退出代码终止），或执行一些特殊处理来

检测哪个出站查询失败。回弹消息主体中的查询不应执行。

在某些情况下，必须使用不可回弹的内部消息。例如，新账户不能在没有至少一个发送到其的不可回弹内部消息的情况下创建。
除非该消息包含新智能合约的代码和数据的 StateInit，否则在不可回弹的内部消息中具有非空消息体没有意义。

建议不要允许最终用户（例如钱包用户）发送携带大额价值（例如，超过五 Gram）的不可回弹消息，或者至少在他们尝试时警告他们。
更好的做法是首先发送少量金额，然后初始化新智能合约，然后再发送较大的金额。

4. 外部消息
~~~~~~~~~~~~

外部消息是从外部发送到 TON 区块链上托管的智能合约，以使它们执行某些操作。
例如，钱包智能合约期望接收包含订单的外部消息（例如，要从钱包智能合约发送的内部消息），这些订单由钱包的所有者签名；
当钱包智能合约收到这样的外部消息时，它首先检查签名，然后接受消息（通过运行 TVM 原语 ACCEPT），然后执行所需的操作。

请注意，所有外部消息必须保护免受重放攻击。验证者通常会从建议的外部消息池中删除外部消息（从网络接收）；
然而，在某些情况下，另一个验证者可能会处理相同的外部消息两次（从而为相同的外部消息创建第二个交易，导致原始操作的重复）。
更糟糕的是，恶意行为者可能会从包含处理交易的区块中提取外部消息，并在稍后重新发送。这可能会迫使钱包智能合约重复支付。

保护智能合约免受与外部消息相关的重放攻击的最简单方法是将 32 位计数器 *cur-seqno* 存储在智能合约的持久数据中，并在任何入站外部消息（如有需要）中期待 *req-seqno* 值。
然后，只有当签名有效且 *req-seqno* 等于 *cur-seqno* 时，外部消息才会被 ACCEPT。
在成功处理后，持久数据中的 *cur-seqno* 值会增加 1，因此相同的外部消息永远不会被再次接受。

还可以在外部消息中包含 *expire-at* 字段，并且仅在当前 Unix 时间小于该字段的值时接受外部消息。这种方法可以与 *seqno* 一起使用；
或者，接收智能合约可以将所有最近（未过期）接受的外部消息的哈希集合存储在其持久数据中，如果新外部消息与其中之一重复，则拒绝它。还应进行一些过期消息的垃圾回收，以避免持久数据膨胀。

一般来说，外部消息以 256 位签名（如果需要）、32 位 *req-seqno*（如果需要）、32 位 *expire-at*（如果需要），以及可能的 32 位 *op* 和其他根据 *op* 需要的参数开始。
外部消息的布局不需要像内部消息那样标准化，因为外部消息不是用于不同智能合约之间的交互（由不同的开发人员编写和管理）。

5. 获取方法
~~~~~~~~~~~~

某些智能合约预期实现某些明确定义的获取方法。例如，任何用于 TON DNS 的子域解析智能合约都应实现 get-method "dnsresolve"。
自定义智能合约可以定义其特定的获取方法。
我们目前唯一的一般建议是实现 get-method "seqno"（无参数），返回使用序列号来防止与入站外部方法相关的重放攻击的智能合约的当前 *seqno*，只要这种方法有意义。
