# 要开发 TON 应用程序的人需要关注的元素

## 1.Func and Fift
Func 是一种为编写智能合约而开发的类 C 语言。虽然它可能看起来有点令人困惑，但一旦你习惯了它，这种语言就很有意义，而且事实上，看起来相当全面。 
Fift 是一种基于堆栈的语言，用作与 TON 交互的语言。它包含 TON“理解”的 TVM 和 Fift 汇编指令。

这两种语言都相对较新，这会导致多种潜在错误，尤其是来自新手开发人员的错误。这是 TON 的清单。


## 2.Name collisions
Func 变量和函数可以包含几乎所有合法字符。也就是说，包括加号（var++）、波浪线（~bits）、破折号（foo-bar+baz）以及逗号在内的字符都是有效的变量名和函数名。


## 3.Check the throw values
每次 TVM 执行正常停止时，都会以退出代码 0 或 1 停止。尽管这是自动完成的，但如果通过 throw(0) 或 throw 直接抛出退出代码 0 和 1，TVM 执行可能会以意外方式直接中断。


## 4.Type and store values
Func 是一种严格类型化的语言，其数据结构中存储的内容完全符合它们应该存储的内容。
了解代码的作用以及它可能返回的内容至关重要。
请记住，编译器只关心代码本身，并且只在其初始状态下关心。经过某些操作后，一些变量的存储值可能会发生变化。

读取意外变量的值以及在不应该具有这些方法的数据类型上调用方法（或者它们的返回值没有被正确存储）都是错误，并且不会被跳过作为“警告”或“通知”，而是会导致无法到达的代码。
请注意，存储一个意外的值可能是可以的，但是读取它可能会引起问题。例如，对于整型变量，可能会抛出错误代码 5（整数超出预期范围）。


## 5.您应该对 Fift 和 TVM 汇编指令有所了解
Func 函数经常使用直接的 Fift "asm" 指令构建。审计员必须知道它们的作用，并仔细观察堆栈中的内容。


## 6.与其他区块链不同，TON 不包含回退消息，只有退出代码
在开始编写您的 TON 智能合约之前，仔细考虑退出代码的路线图（并将其记录下来）是有帮助的。


## 7.消息有模式
（由一个数字表示的一组标志），其中之一可能用作自毁，另一个用于将余额上的所有剩余硬币发送出去。
对于 TON 区块链审计员来说，检查消息模式是至关重要的。


## 8.TON 完全实现了 actor 模型
这意味着合约的代码可以被更改。它可以通过使用 SETCODE TVM 指令永久更改，或者在运行时更改，将 TVM 代码注册表设置为新的单元值，直到执行结束。


## 9.TON 区块链有几个交易阶段：计算阶段、动作阶段以及反弹阶段等
计算阶段执行智能合约的代码，然后才执行动作（发送消息、代码修改、更改库等）。
所以，与基于以太坊的区块链不同，如果您期望发送的消息失败，您不会看到计算阶段的退出代码，因为它不是在计算阶段执行的，而是在稍后的动作阶段执行的。


## 10.具有 method_id 标识符的 Func 函数具有方法 ID
它们可以显式设置 "method_id(5)"，或者由 func 编译器隐式设置。在这种情况下，它们可以在 .fift 汇编文件中的方法声明中找到。
其中两个是预定义的：一个用于在区块链内部接收消息（0），通常命名为 recv_internal，另一个用于从外部接收消息（-1），recv_external。


## 11.TON 加密地址可能没有任何硬币或代码
TON 区块链中智能合约的地址是确定性的，并且可以预计算。
与地址关联的 Ton 账户甚至可能不包含任何代码，这意味着它们未初始化（如果未部署）或者在发送了具有特殊标志的消息后被冻结，同时如果消息具有特殊标志，它们可能没有更多的存储或 TON 硬币。


## 12.TON 地址可能有三种表示形式
完整表示可以是“原始”的（workchain:address）或“用户友好”的。后者是用户最常遇到的形式。它包含一个标签字节，指示地址是否可以反弹，以及一个工作链 id 字节。这些信息应该被记录下来。


## 13.跟踪代码执行中的缺陷
与 Solidity 不同，您可以设置方法的可见性，在 Func 的情况下，可见性以更复杂的方式受到限制，要么显示错误，要么通过 "if" 语句。


## 14.在发送反弹消息之前注意 gas
如果智能合约发送用户提供价值的反弹消息，请确保相应的 gas 费用从返回的金额中减去，以免被耗尽。


## 15.监控回调及其故障
TON 区块链是异步的。这意味着消息不必连续到达。例如，当一个动作的失败通知到达时，应该正确处理。


## 16.检查接收内部消息时是否发送了反弹标志
您可能会收到反弹消息（错误通知），应该处理这些消息。


## 17.为外部消息编写重放保护：
有两种自定义解决方案适用于钱包（智能合约，存储用户的钱）：基于 seqno（检查计数器，不要两次处理消息）和高负载（存储进程标识符及其过期时间）。

对于没有准备的审计员或开发者来说，TON 可能看起来像是一个复杂的链，但是知道期待什么可以给您带来明显的优势。
上述 17 个技巧对于部署到 TON 的任何智能合约都可以产生巨大的影响。


---
# TVM

今天我要回顾一下TVM，它如何工作，它的设计方式，以及它未来的发展方向。

TVM 被包括 TON 本身在内的 4 个不同项目使用，现在已经有了 Rust 和 C++ 的实现。TVM 是 FunC、Tact 合约背后的虚拟机。

TVM 使用 actor 模型进行合约设计，TON 协议或 TVM 中的一切都将被视为 actor/合约（我稍后会另发一篇帖子解释 actor 模型）。例如，TON 上的账户是钱包合约，它们是 actor。在其他虚拟机中，我们可以看到面向对象、面向资源和函数式范式。

## 1.TVM 是一个栈式机器；TVM 的存储和状态
TVM 将值存储在 LIFO（后进先出）栈中，而不是存储在“变量”或“通用寄存器”中。例如，ADD 操作（或任何用户定义的函数）不会从某些变量中选择值，将它们推入寄存器，并将它们相加。相反，它将从栈中选择最后两个数字，将它们相加，并将它们的和推到栈顶。

由于 TVM 是一个栈式机器，因此缺少通用寄存器，但我们可以考虑将栈上的最后一个值/项视为栈寄存器。通过将最后一个值称为 s0，它之后的第二个值称为 s1，依此类推。栈中的值的数量称为栈的深度。

向栈中推入 —— 一旦我们将一个新值推入栈中，我们的新值就变成了 s0，旧的 s0 变成了新的 s1，旧的 s1 变成了新的 s2，依此类推。

从栈中弹出 —— 当我们从栈中弹出一个值时，s1 将变成新的 s0，s2 变成新的 s1，依此类推。

当栈的深度等于零时，意味着栈为空，任何尝试从其中弹出值的操作都会发生栈下溢异常。

让我们以这个模型为例：

当您调用/使用一个需要 m 个参数的函数时，X1 … Xm，您将它们按照 X1 开始的顺序推入栈中。一旦您调用函数，它需要的第一个项（x1）位于 s(m-1)，第二个（x2）位于 s(m-2)，依此类推。最后一个参数（Xm）位于 s0。

一旦操作完成，从栈中移除这些值（弹出）并将结果推入栈（结果位于 s0）是函数或原语的责任。

如果被调用的函数需要返回两个或更多的值（y1, … yx），它可以按照它们的正常顺序将它们推入栈。首先是 y1，依此类推……

### 1.1. 值/数据类型；静态类型、动态类型和运行时类型检查
TVM 上的值或数据类型是预定义的，并且内置操作只接受这些类型。例如，标志性操作 ADD 需要两个整数作为输入，并返回一个整数作为输出。你不能传递一个字符串给它并期望它计算其二进制表示的和。

这些值在栈上有一个标签，这意味着 TVM 栈上的每一项数据都有一个显示其数据类型的标签。这意味着 TVM 使用运行时类型检查模型。

但是运行时类型检查并不会让 TVM 代码/语言成为像 JavaScript 或 PHP 这样的动态类型语言，因为所有预定义操作获取输入和返回输出的值都是预定义（值）类型，每个值严格属于一种类型，并且值从不隐式地从一种类型转换为另一种类型。

例如，你不能将一个字符串的地址作为整数使用，或者将一个整数作为字符串的地址使用！这有助于使 TVM 更加安全和安全。

TVM 为栈中的每个值添加了一个带有数据类型的标签，而不是根据操作的需要重新解释寄存器中的位序列，这只是额外的运行时类型安全机制。

TVM 支持不同的类型，如整数（目前只有一个类型 int256），元组，单元等。你可以在这里详细查看类型。

我们应该考虑在 TVM 中 Cell 数据类型的重要性。我稍后会专门写一篇关于单元的完整文章。

### 1.2. 控制寄存器
正如我们所说的，TVM 中的值保存在栈中，但一些很少改变且大多数函数需要的值保存在控制寄存器中，称为 c0 — c15。当前版本的 TVM 只支持 c0 到 c7，但在未来的版本中，其余的也可以使用。

你可以在这里找到控制寄存器的列表。

### 1.3. TVM 总状态（SCCCG）
TVM 的总状态是 TVM 存储和状态设计的最后部分。这些都是 TVM 跟踪的所有状态。

栈 — 保存所有值及其类型标签的栈。
控制寄存器 — c0–c15 寄存器，由于 TVM 是栈机器，它们不是通用的。
当前继续 — 包含在当前原语完成后将执行的指令。在其他架构中，它们称之为指令指针或（ip）。
当前代码页 — 一个特殊的有符号 16 位整数值，它选择下一个 TVM 操作码的解码方式。
Gas 限制 — 包含四个有符号 64 位整数，当前 Gas 限制，最大 Gas 限制，剩余 Gas，以及 Gas 信用。


## 2.TVM 指令和原语
在 TVM 中，指令或原语有时称为内置操作，指的是由 TVM 提供的原子操作。高级 TVM 代码，如 Fift、FunC 或 Tact 代码，将被编译成这些内置操作。

这些指令中有些是栈、元组和单元的操作。有些则是算术操作。你可以在这里找到完整列表。

另一类指令是自定义的或特定于应用程序的原语，它们是用户定义的函数或应用程序所需的高级操作，例如计算哈希、发送区块链消息等。

TVM 论文 1.2 类别中的 TVM 指令：

这些原语对应于标准库函数而不是微处理器指令。

但要考虑到，内置的自定义操作也是在 TVM 实现中定义的，而不是标准库。你可能在第一次时像我一样误解了这一点。


## 3.Gas 价格
每个 TVM 指令在其定义中都有一个特定的 Gas 价格。单元创建或元组创建有更多的 Gas 价格。此外，移动栈元素操作需要 1 个 Gas 单位，但栈上的前 32 次操作是免费的。

你也可以在这里[https://docs.ton.org/learn/tvm-instructions/instructions#gas-prices]找到关于 Gas 的良好解释。


---

ref[1]: https://0xguard.com/things_to_focus_on_while_working_with_ton_blockchain

ref[2]: https://kehiy.medium.com/ton-virtual-machine-its-design-and-how-it-works-5e6a8fba3bf7